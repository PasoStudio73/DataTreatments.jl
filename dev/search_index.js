var documenterSearchIndex = {"docs":
[{"location":"api/#dtattreatments","page":"Api","title":"DataTreatments","text":"","category":"section"},{"location":"api/#DataTreatments.FeatureId","page":"Api","title":"DataTreatments.FeatureId","text":"FeatureId{T<:ValidVnames} <: AbstractFeatureId\n\nA metadata container for individual features in a processed dataset.\n\nThis struct stores information about each feature column, including the source variable name, the transformation function applied, and the window number. It is designed for:\n\nExperiment documentation: All feature extraction parameters are preserved for reproducibility\nFeature selection: Metadata enables intelligent feature filtering and selection strategies\nTraceability: Each feature can be traced back to its source variable and transformation\n\nFields\n\nvname::Symbol: Source variable name from the original dataset\nfeat::Base.Callable: Feature extraction function (e.g., mean, std, maximum)\nnwin::Int64: Window number (1 for single window, >1 for multiple windows)\n\nType Parameters\n\nT<:ValidVnames: Type of variable name (Symbol or String)\n\nExamples\n\n# Single window feature\nfid = FeatureId(:temperature, mean, 1)\n# Displays as: mean(temperature)\n\n# Multi-window feature\nfid = FeatureId(:pressure, maximum, 3)\n# Displays as: maximum(pressure)_w3\n\n# Access metadata\nget_vname(fid)    # :pressure\nget_feature(fid)  # maximum\nget_nwin(fid)     # 3\n\nSee Also\n\nDataTreatment: Main container using FeatureId for metadata\n\n\n\n\n\n","category":"type"},{"location":"api/#DataTreatments.DataTreatment","page":"Api","title":"DataTreatments.DataTreatment","text":"DataTreatment{T, S} <: AbstractDataTreatment\n\nA container for processed multidimensional data with complete metadata for reproducibility.\n\nThis struct stores the transformed dataset along with all processing parameters, ensuring full experiment documentation and reproducibility.\n\nFields\n\ndataset::AbstractMatrix{T}: Processed flat feature matrix (samples Ã— features)\nfeatureid::Vector{FeatureId}: Metadata for each feature column (enables feature selection)\nreducefunc::Base.Callable: Reduction function used (for :reducesize mode)\naggrtype::Symbol: Processing type (:aggregate or :reducesize)\n\nType Parameters\n\nT: Element type of the output dataset\nS: Core element type for nested structures\n\nConstructor\n\nDataTreatment(\n    X::Union{AbstractMatrix, AbstractDataFrame},\n    aggrtype::Symbol;\n    vnames::Vector{<:ValidVnames},\n    win::Union{Base.Callable, Tuple{Vararg{Base.Callable}}},\n    features::Tuple{Vararg{Base.Callable}}=(maximum, minimum, mean),\n    reducefunc::Base.Callable=mean,\n)\n\nArguments\n\nX: Input data (Matrix or DataFrame with multidimensional elements)\naggrtype: Processing mode (:aggregate or :reducesize)\nvnames: Variable names for feature identification\nwin: Window function(s) for data partitioning\nfeatures: Tuple of statistical functions to apply (default: (maximum, minimum, mean))\nreducefunc: Reduction function for :reducesize mode (default: mean)\n\nProcessing Modes\n\n:reducesize Mode\n\nApplies multiple feature functions to windowed regions, preserving the dataset structure. Each element is reduced but the matrix dimensions are maintained.\n\nXmatrix = fill(rand(200, 120), 100, 10)  # 100 samples, 10 variables\nwin = splitwindow(nwindows=4)\nfeatures = (mean, std, maximum)\n\ndt = DataTreatment(Xmatrix, :reducesize; \n                   vnames=Symbol.(\"var\", 1:10),\n                   win=(win,), \n                   features=features)\n# Each 200Ã—120 element becomes 4Ã—4, resulting in 100Ã—10 output\n\n:aggregate Mode\n\nFlattens multidimensional data into a single feature matrix suitable for ML models. Applies multiple features across windows and concatenates results.\n\ndt = DataTreatment(Xmatrix, :aggregate;\n                   vnames=Symbol.(\"var\", 1:10),\n                   win=(win,),\n                   features=features)\n# Returns 100Ã—(10Ã—3Ã—16) = 100Ã—480 flat matrix\n# 10 vars Ã— 3 features Ã— 16 windows (4Ã—4 grid)\n\nExamples\n\nBasic Usage with DataFrame\n\nusing DataFrames\n\n# Create dataset with multidimensional elements\ndf = DataFrame(\n    channel1 = [rand(200, 120) for _ in 1:1000],\n    channel2 = [rand(200, 120) for _ in 1:1000],\n    channel3 = [rand(200, 120) for _ in 1:1000]\n)\n\n# Define processing parameters\nwin = adaptivewindow(nwindows=6, overlap=0.15)\nfeatures = (mean, std, maximum, minimum, median)\n\n# Process to tabular format\ndt = DataTreatment(df, :reducesize; \n                   win=(win,), \n                   features=features)\n\n# Access processed data\nX_flat = get_dataset(dt)        # Flat feature matrix\nfeature_ids = get_featureid(dt) # Feature metadata\n\nFeature Selection Using Metadata\n\n# Get all feature metadata\nfeature_ids = get_featureid(dt)\n\n# Select specific features\nmean_features = findall(fid -> get_feature(fid) == mean, feature_ids)\nX_means = dt.dataset[:, mean_features]\n\n# Select features from specific variable\nch1_features = findall(fid -> get_vname(fid) == :channel1, feature_ids)\nX_ch1 = dt.dataset[:, ch1_features]\n\n# Select features from specific windows\nearly_windows = findall(fid -> get_nwin(fid) <= 3, feature_ids)\nX_early = dt.dataset[:, early_windows]\n\nReproducibility and Documentation\n\n# All parameters are stored for experiment reproduction\ndt = DataTreatment(df, :reducesize; win=(win,), features=features)\n\n# Extract processing metadata\naggrtype = get_aggrtype(dt)       # :reducesize\nreduction = get_reducefunc(dt)    # mean\nvar_names = get_vnames(dt)        # [:channel1, :channel2, :channel3]\nfeat_funcs = get_features(dt)     # (mean, std, maximum, minimum, median)\nn_windows = get_nwindows(dt)      # 6\n\n# Document experiment\nprintln(\"Processing: $aggrtype mode\")\nprintln(\"Variables: $(join(var_names, \", \"))\")\nprintln(\"Features: $(join(nameof.(feat_funcs), \", \"))\")\nprintln(\"Windows: $n_windows per dimension\")\n\nAccessor Functions\n\nget_dataset(dt): Extract the processed feature matrix\nget_featureid(dt): Get feature metadata vector\nget_reducefunc(dt): Get the reduction function used\nget_aggrtype(dt): Get the processing mode\nget_vnames(dt): Get unique variable names\nget_features(dt): Get unique feature functions\nget_nwindows(dt): Get maximum window number\n\nIndexing\n\nDataTreatment supports array-like indexing:\n\ndt[1, :]      # First sample (row)\ndt[:, 1]      # First feature (column)\ndt[1:10, :]   # First 10 samples\nsize(dt)      # Dataset dimensions\nlength(dt)    # Number of features\n\nSee Also\n\nFeatureId: Individual feature metadata\napplyfeat: Single array feature extraction\naggregate: Multi-element aggregation\nreducesize: Flatten to tabular format\n@evalwindow: Window evaluation macro\n\n\n\n\n\n","category":"type"},{"location":"api/#treatments","page":"Api","title":"Treatments","text":"","category":"section"},{"location":"api/#DataTreatments.applyfeat","page":"Api","title":"DataTreatments.applyfeat","text":"applyfeat(X::AbstractArray, intervals::Tuple{Vararg{Vector{UnitRange{Int64}}}}[; reducefunc::Base.Callable=mean]) -> AbstractArray\n\nApply a reduction function to windows defined by intervals over an array.\n\nThis function performs dimensionality reduction on an n-dimensional array by dividing it into  windows and applying an aggregation function to each window.\n\nA reduction function (also called aggregation function) is a function that takes  multiple values and returns a single summary value, such as mean, maximum, minimum,  std, median, or mode.\n\nArguments\n\nX::AbstractArray: Input array to process\nintervals::Tuple{Vararg{Vector{UnitRange{Int64}}}}: Tuple of vectors, each containing ranges  defining windows along each dimension of X\nreducefunc::Base.Callable=mean: Function to apply to each window (default: mean)\n\nReturns\n\nAbstractArray: Reduced array with dimensions matching the number of windows in each dimension\n\nExample\n\nX = rand(100, 120)\nwfunc = splitwindow(nwindows=10)\nintervals = @evalwindow X wfunc\nresult = applyfeat(X, intervals; reducefunc=maximum)\n# Returns a 2Ã—3 matrix containing maximum values for each window\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.reducesize","page":"Api","title":"DataTreatments.reducesize","text":"reducesize(X::AbstractArray, intervals::Tuple{Vararg{Vector{UnitRange{Int64}}}}[; reducefunc::Base.Callable=mean]) -> AbstractArray\n\nApply window-based size-reduction to each element of an array.\n\nThis function is designed for arrays where each element is itself an array (e.g., Matrix{Matrix{Float64}}). It applies applyfeat to each element.\n\nArguments\n\nX::AbstractArray: Input array where each element is an array to be size-reduced\nintervals::Tuple{Vararg{Vector{UnitRange{Int64}}}}: Window definitions for aggregation\nreducefunc::Base.Callable=mean: Function to apply to each window (default: mean)\n\nReturns\n\nAbstractArray: Array with same outer dimensions as X, each element containing size-reduced results\n\nExample\n\nX = rand(100, 120)\nXmatrix = fill(X, 100, 10)\nwfunc = splitwindow(nwindows=3)\nintervals = @evalwindow X wfunc\nresult = reducesize(Xmatrix, intervals; reducefunc=std)\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.aggregate","page":"Api","title":"DataTreatments.aggregate","text":"aggregate(X::AbstractArray, intervals::Tuple{Vararg{Vector{UnitRange{Int64}}}}[; features::Tuple{Vararg{Base.Callable}}=(mean,)]) -> AbstractArray\n\nFlatten nested arrays by applying multiple feature functions to windowed regions.\n\nThis function takes a matrix of arrays (e.g., Matrix{Matrix{Float64}}) and produces a single flat matrix where each row corresponds to a row in X, and columns contain flattened features computed from windowed aggregations.\n\nUse Case\n\nThis function enables the analysis of datasets containing n-dimensional elements (such as images,  time series, or spectrograms) with machine learning models that require tabular input. It transforms  complex multi-dimensional data into a flat feature matrix suitable for standard ML algorithms.\n\nArguments\n\nX::AbstractArray: Input array where each element is an array (e.g., Matrix{Matrix{Float64}})\nintervals::Tuple{Vararg{Vector{UnitRange{Int64}}}}: Window definitions for aggregation\nfeatures::Tuple{Vararg{Base.Callable}}=(mean,): Tuple of functions to compute on each window\n\nReturns\n\nAbstractArray: Flattened array with dimensions (nrows(X), ncols(X) Ã— n_features Ã— n_windows) where each element is of type core_eltype(X)\n\nDetails\n\nThe output columns are organized as: for each column in X, all features are computed for all windows, with results concatenated in the order: [col1_feat1_win1, col1_feat1_win2, col1_feat2_win1, ...]\n\nExample\n\nX = rand(100, 120)\nXmatrix = fill(X, 100, 10)\nwfunc = splitwindow(nwindows=3)\nintervals = @evalwindow X wfunc\nfeatures = (mean, maximum)\nresult = aggregate(Xmatrix, intervals; features)\n\n\n\n\n\n","category":"function"},{"location":"api/#windowing","page":"Api","title":"Windowing","text":"","category":"section"},{"location":"api/#DataTreatments.movingwindow","page":"Api","title":"DataTreatments.movingwindow","text":"movingwindow(; winsize::Int64[, winstep::Int64]) -> Function\n\nCreates a moving (sliding) window function with fixed window size and step.\n\nKeyword Arguments\n\nwinsize::Int64: Size of each window\nwinstep::Int64: Step between consecutive windows (defaults to winsize if 0)\n\nReturns\n\nFunction: A function that takes npoints::Int64 and returns Vector{UnitRange{Int64}}\n\nExample\n\nwfunc = movingwindow(winsize=10, winstep=5)\nwindows = wfunc(100)  # apply to sequence of length 100\n\nUse with macro\n\nA = rand(200)\nwindows = @evalwindow A movingwindow(winsize=10, winstep=5)\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.wholewindow","page":"Api","title":"DataTreatments.wholewindow","text":"wholewindow() -> Function\n\nCreates a window function that returns a single window covering the entire sequence.\n\nReturns\n\nFunction: A function that takes npoints::Int64 and returns a single window [1:npoints]\n\nExample\n\nwfunc = wholewindow()\nwindows = wfunc(100)  # returns [1:100]\n\nUse with macro\n\nA = rand(200)\nwindows = @evalwindow A wholewindow()\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.splitwindow","page":"Api","title":"DataTreatments.splitwindow","text":"splitwindow(; nwindows::Int64) -> Function\n\nCreates a window function that splits the sequence into a fixed number of non-overlapping windows.\n\nKeyword Arguments\n\nnwindows::Int64: Number of windows to create\n\nReturns\n\nFunction: A function that takes npoints::Int64 and returns Vector{UnitRange{Int64}}\n\nExample\n\nwfunc = splitwindow(nwindows=5)\nwindows = wfunc(100)  # splits into 5 equal windows\n\nUse with macro\n\nA = rand(200)\nwindows = @evalwindow A splitwindow(nwindows=5)\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.adaptivewindow","page":"Api","title":"DataTreatments.adaptivewindow","text":"adaptivewindow(; nwindows::Int64[, overlap::Float64=0.0]) -> Function\n\nCreates a window function that adaptively divides the sequence into windows with optional overlap.\n\nKeyword Arguments\n\nnwindows::Int64: Number of windows to create\noverlap::Float64: Relative overlap between windows (0.0 to 1.0), defaults 0.0.\n\nReturns\n\nFunction: A function that takes npoints::Int64 and returns Vector{UnitRange{Int64}}\n\nExample\n\nwfunc = adaptivewindow(nwindows=5, overlap=0.2)\nwindows = wfunc(100)  # 5 windows with 20% overlap\n\nUse with macro\n\nA = rand(200)\nwindows = @evalwindow A adaptivewindow(nwindows=5, overlap=0.2)\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.@evalwindow","page":"Api","title":"DataTreatments.@evalwindow","text":"@evalwindow(X, winfuncs...) -> Tuple{Vararg{Vector{UnitRange{Int64}}}}\n\nApply window functions to each dimension of an array.\n\nThis macro evaluates window functions for each dimension of an array, automatically  determining the appropriate number of points from the array's size. If fewer window  functions are provided than dimensions, the last function is reused for remaining dimensions.\n\nArguments\n\nX: Input array whose dimensions determine window parameters\nwinfuncs...: One or more window functions (e.g., movingwindow(), splitwindow(), adaptivewindow())\n\nReturns\n\nTuple{Vararg{Vector{UnitRange{Int64}}}}: Tuple of vectors containing window ranges for each dimension\n\nBehavior\n\nEach window function is applied to the corresponding dimension size\nIf length(winfuncs) < ndims(X), the last function is repeated for remaining dimensions\nWindow functions must be created using movingwindow, splitwindow, adaptivewindow, or wholewindow\n\nExamples\n\nSingle dimension\n\nX = rand(200)\nwindows = @evalwindow X movingwindow(winsize=50, winstep=25)\n\nTwo dimensions with different windows\n\nX = rand(200, 120)\nwindows = @evalwindow X splitwindow(nwindows=4) adaptivewindow(nwindows=3, overlap=0.1)\n# First dimension: 4 non-overlapping windows\n\nReusing window function for multiple dimensions\n\nX = rand(100, 120, 80)\nwindows = @evalwindow X splitwindow(nwindows=5)\n\nUse with processing functions\n\nX = rand(200, 120)\nintervals = @evalwindow X splitwindow(nwindows=4) splitwindow(nwindows=3)\nresult = applyfeat(X, intervals; reducefunc=mean)\n\nSee Also\n\nmovingwindow: Fixed-size sliding windows\nsplitwindow: Equal non-overlapping windows\nadaptivewindow: Windows with overlap\nwholewindow: Single window covering entire dimension\n\n\n\n\n\n","category":"macro"},{"location":"api/#featuresets","page":"Api","title":"Featuresets","text":"","category":"section"},{"location":"api/#Basic-Statistics","page":"Api","title":"Basic Statistics","text":"","category":"section"},{"location":"api/","page":"Api","title":"Api","text":"Standard statistical measures: maximum, minimum, mean, median, std, cov","category":"page"},{"location":"api/#Catch22-Features","page":"Api","title":"Catch22 Features","text":"","category":"section"},{"location":"api/","page":"Api","title":"Api","text":"Canonical time-series characteristics covering:","category":"page"},{"location":"api/","page":"Api","title":"Api","text":"Distribution properties and extreme events\nLinear and nonlinear autocorrelation structures  \nForecasting performance and scaling properties\nSymbolic dynamics and transition patterns","category":"page"},{"location":"api/#Predefined-Feature-Sets","page":"Api","title":"Predefined Feature Sets","text":"","category":"section"},{"location":"api/","page":"Api","title":"Api","text":"base_set: Minimal statistical features (4 features)\ncatch9: Curated subset combining statistics + key Catch22 (9 features)  \ncatch22_set: Complete Catch22 suite (22 features)\ncomplete_set: All features combined (28 features)","category":"page"},{"location":"api/#References","page":"Api","title":"References","text":"","category":"section"},{"location":"api/","page":"Api","title":"Api","text":"The Catch22 features are based on the Canonical Time-series Characteristics:","category":"page"},{"location":"api/","page":"Api","title":"Api","text":"Repository: https://github.com/DynamicsAndNeuralSystems/catch22\nPaper: Lubba, C.H., Sethi, S.S., Knaute, P. et al. \"catch22: CAnonical Time-series CHaracteristics.\" Data Min Knowl Disc 33, 1821â€“1852 (2019). https://doi.org/10.1007/s10618-019-00647-x","category":"page"},{"location":"api/#DataTreatments.base_set","page":"Api","title":"DataTreatments.base_set","text":"base_set\n\nA minimal feature set containing only basic statistical measures for time series analysis.\n\nFeatures\n\nmaximum: Maximum value in the time series\nminimum: Minimum value in the time series  \nmean   : Arithmetic mean of the time series\nstd    : Standard deviation of the time series\n\n\n\n\n\n","category":"constant"},{"location":"api/#DataTreatments.catch9","page":"Api","title":"DataTreatments.catch9","text":"catch9\n\nA curated subset of 9 features combining basic statistics with Symbolic Catch22 measures,\n\nFeatures\n\nBasic statistics: maximum, minimum, mean, median, std\nSymbolic Catch22 features:\nstretch_high       : Measures persistence of high values\nstretch_decreasing : Captures decreasing trend patterns\nentropy_pairs      : Quantifies local pattern complexity\ntransition_variance: Measures state transition variability\n\nReferences\n\nThe Catch22 features are based on the CAnonical Time-series CHaracteristics from:\n\nRepository: https://github.com/DynamicsAndNeuralSystems/catch22\nArticle:    https://doi.org/10.1007/s10618-019-00647-x\nAuthor: Carl H. Lubba et al\n\n\n\n\n\n","category":"constant"},{"location":"api/#DataTreatments.catch22_set","page":"Api","title":"DataTreatments.catch22_set","text":"catch22_set\n\nThe complete Catch22 feature set. Each feature captures different aspects of time series dynamics including correlation structure, distribution properties and temporal patterns.\n\nFeature Categories\n\nDistribution shape:  mode_5, mode_10\nExtreme event timing: outlier_timing_pos, outlier_timing_neg\nLinear autocorrelation: acf_timescale, acf_first_min, low_freq_power, centroid_freq\nSimple forecasting: forecast_error\nIncremental differences: whiten_timescale, high_fluctuation\nSymbolic stretch_high, stretch_decreasing, entropy_pairs, transition_variance\nNonlinear autocorrelation: ami2, trev\nLinear autocorrelation structure: ami_timescale, periodicity\nSelf-affine scaling: rs_range, dfa\nOther: embedding_dist\n\nReferences\n\nThe Catch22 features are based on the CAnonical Time-series CHaracteristics from:\n\nRepository: https://github.com/DynamicsAndNeuralSystems/catch22\nArticle:    https://doi.org/10.1007/s10618-019-00647-x\nAuthor: Carl H. Lubba et al\n\n\n\n\n\n","category":"constant"},{"location":"api/#DataTreatments.complete_set","page":"Api","title":"DataTreatments.complete_set","text":"complete_set\n\nThe most comprehensive feature set combining basic statistical measures, covariance analysis, and the full Catch22 suite.\n\nFeatures\n\nBasic statistics: maximum, minimum, mean, median, std, cov\nDistribution shape:  mode_5, mode_10\nExtreme event timing: outlier_timing_pos, outlier_timing_neg\nLinear autocorrelation: acf_timescale, acf_first_min, low_freq_power, centroid_freq\nSimple forecasting: forecast_error\nIncremental differences: whiten_timescale, high_fluctuation\nSymbolic stretch_high, stretch_decreasing, entropy_pairs, transition_variance\nNonlinear autocorrelation: ami2, trev\nLinear autocorrelation structure: ami_timescale, periodicity\nSelf-affine scaling: rs_range, dfa\nOther: embedding_dist\n\n\n\n\n\n","category":"constant"},{"location":"api/#All-Catch22-Features","page":"Api","title":"All Catch22 Features","text":"","category":"section"},{"location":"api/#DataTreatments.mode_5","page":"Api","title":"DataTreatments.mode_5","text":"DN_HistogramMode_5(x::AbstractVector{Union{Float64, Int}}) # For example\n\nAn alternative to catch22(:DN_HistogramMode_5](x). All features, such as DN_HistogramMode_5, are exported as Features and can be evaluated by calling their names.\n\nExamples\n\nð± = Catch22.testdata[:test]\nf = DN_HistogramMode_5(ð±)\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.mode_10","page":"Api","title":"DataTreatments.mode_10","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.embedding_dist","page":"Api","title":"DataTreatments.embedding_dist","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.acf_timescale","page":"Api","title":"DataTreatments.acf_timescale","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.acf_first_min","page":"Api","title":"DataTreatments.acf_first_min","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.ami2","page":"Api","title":"DataTreatments.ami2","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.trev","page":"Api","title":"DataTreatments.trev","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.outlier_timing_pos","page":"Api","title":"DataTreatments.outlier_timing_pos","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.outlier_timing_neg","page":"Api","title":"DataTreatments.outlier_timing_neg","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.whiten_timescale","page":"Api","title":"DataTreatments.whiten_timescale","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.forecast_error","page":"Api","title":"DataTreatments.forecast_error","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.ami_timescale","page":"Api","title":"DataTreatments.ami_timescale","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.high_fluctuation","page":"Api","title":"DataTreatments.high_fluctuation","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.stretch_decreasing","page":"Api","title":"DataTreatments.stretch_decreasing","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.stretch_high","page":"Api","title":"DataTreatments.stretch_high","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.entropy_pairs","page":"Api","title":"DataTreatments.entropy_pairs","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.rs_range","page":"Api","title":"DataTreatments.rs_range","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.dfa","page":"Api","title":"DataTreatments.dfa","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.low_freq_power","page":"Api","title":"DataTreatments.low_freq_power","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.centroid_freq","page":"Api","title":"DataTreatments.centroid_freq","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.transition_variance","page":"Api","title":"DataTreatments.transition_variance","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.periodicity","page":"Api","title":"DataTreatments.periodicity","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"#DataTreatments.jl","page":"Home","title":"DataTreatments.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for processing datasets containing multidimensional elements through windowing and dimensionality reduction techniques.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataTreatments.jl provides tools for working with matrices, or DataFrames where each element is itself a multidimensional object (vectors, matrices, or higher-dimensional arrays). It offers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Windowing functions for partitioning multidimensional data\nDimensionality reduction using feature extraction together with windowing\nTabular transformation through feature extraction to convert complex multidimensional datasets into flat feature matrices suitable for standard machine learning models\nComplete reproducibility by storing all processing parameters and feature metadata","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is particularly useful when you need to apply traditional ML algorithms that require tabular input to datasets containing structured multidimensional elements like images, spectrograms, or time series segments.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataTreatments\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DataTreatments\n\n# Create a dataset with multidimensional elements\nX = rand(200, 120)  # Example: 200Ã—120 matrix (e.g., spectrogram)\nXmatrix = fill(X, 100, 10)  # 100Ã—10 dataset where each element is a 200Ã—120 matrix\n\n# Define windowing strategy\nwin = splitwindow(nwindows=4)  # Split into 4 equal windows per dimension\n\n# Compute intervals for the first element\nintervals = @evalwindow X win\n\n# Apply multiple statistical features to each window\nfeatures = (mean, std, maximum, minimum)\nresult = aggregate(Xmatrix, intervals; features)\n\n# Result is a 100Ã—10 matrix where each element is reduced to 4Ã—4","category":"page"},{"location":"#Core-Concepts","page":"Home","title":"Core Concepts","text":"","category":"section"},{"location":"#Windowing-Functions","page":"Home","title":"Windowing Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataTreatments provides several windowing strategies:","category":"page"},{"location":"#splitwindow-Equal-Non-Overlapping-Windows","page":"Home","title":"splitwindow - Equal Non-Overlapping Windows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"win = splitwindow(nwindows=3)\n# Divides data into 3 equal, non-overlapping segments","category":"page"},{"location":"#movingwindow-Fixed-Size-Sliding-Windows","page":"Home","title":"movingwindow - Fixed-Size Sliding Windows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"win = movingwindow(winsize=50, winstep=25)\n# Creates overlapping windows of size 50, advancing by 25 points","category":"page"},{"location":"#adaptivewindow-Windows-with-Controlled-Overlap","page":"Home","title":"adaptivewindow - Windows with Controlled Overlap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"win = adaptivewindow(nwindows=5, overlap=0.2)\n# Creates 5 windows with 20% overlap between consecutive windows","category":"page"},{"location":"#wholewindow-Single-Window-(Entire-Dimension)","page":"Home","title":"wholewindow - Single Window (Entire Dimension)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"win = wholewindow()\n# Creates a single window covering the entire dimension","category":"page"},{"location":"#Multi-Dimensional-Windowing","page":"Home","title":"Multi-Dimensional Windowing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use the @evalwindow macro to apply window functions to each dimension:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = rand(200, 120)\n\n# Apply same windowing to all dimensions\nintervals = @evalwindow X splitwindow(nwindows=4)\n\n# Apply different windowing per dimension\nintervals = @evalwindow X splitwindow(nwindows=4) movingwindow(winsize=40, winstep=20)","category":"page"},{"location":"#Feature-Extraction-Functions","page":"Home","title":"Feature Extraction Functions","text":"","category":"section"},{"location":"#applyfeat-Apply-Reduction-to-a-Single-Array","page":"Home","title":"applyfeat - Apply Reduction to a Single Array","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"X = rand(200, 120)\nintervals = @evalwindow X splitwindow(nwindows=4)\n\n# Apply mean to each window\nresult = applyfeat(X, intervals; reducefunc=mean)\n# Returns a 4Ã—4 matrix (4 windows per dimension)","category":"page"},{"location":"#reducesize-Apply-to-Dataset-Elements","page":"Home","title":"reducesize - Apply to Dataset Elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Xmatrix = fill(rand(200, 120), 100, 10)  # Dataset of matrices\nintervals = @evalwindow first(Xmatrix) splitwindow(nwindows=3)\n\n# Aggregate each element using reduce feature\nresult = reducesize(Xmatrix, intervals; reducefunc=mean)\n# Each element reduced from 200Ã—120 to a 3Ã—3 matrix per feature","category":"page"},{"location":"#aggregate-Flatten-to-Tabular-Format","page":"Home","title":"aggregate - Flatten to Tabular Format","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Xmatrix = fill(rand(200, 120), 100, 10)  # 100 samples, 10 variables\nintervals = @evalwindow first(Xmatrix) splitwindow(nwindows=4)\nfeatures = (mean, std, maximum, minimum)\n\nresult = aggregate(Xmatrix, intervals; features)\n# Returns 100Ã—640 matrix (10 vars Ã— 4 features Ã— 16 windows)","category":"page"},{"location":"#Data-Structures","page":"Home","title":"Data Structures","text":"","category":"section"},{"location":"#FeatureId-Feature-Metadata","page":"Home","title":"FeatureId - Feature Metadata","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A metadata container that stores information about each feature column for reproducibility and feature selection:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Created automatically by DataTreatment\ndt = DataTreatment(df, :reducesize; win=(win,), features=(mean, std, maximum))\n\n# Access feature metadata\nfeature_ids = get_featureid(dt)\n\n# Each FeatureId contains:\n# - vname: Source variable name\n# - feat: Feature function applied\n# - nwin: Window number\n\n# Use for feature selection\nmean_features = filter(fid -> get_feature(fid) == mean, feature_ids)\ntemp_features = filter(fid -> get_vname(fid) == :temperature, feature_ids)\nwindow1_features = filter(fid -> get_nwin(fid) == 1, feature_ids)","category":"page"},{"location":"#DataTreatment-Complete-Processing-Container","page":"Home","title":"DataTreatment - Complete Processing Container","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A comprehensive container that stores processed data along with all parameters for full reproducibility:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DataFrames, Statistics\n\n# Create dataset\ndf = DataFrame(\n    channel1 = [rand(200, 120) for _ in 1:1000],\n    channel2 = [rand(200, 120) for _ in 1:1000],\n    channel3 = [rand(200, 120) for _ in 1:1000]\n)\n\n# Process with full parameter storage\nwin = adaptivewindow(nwindows=6, overlap=0.15)\nfeatures = (mean, std, maximum, minimum, median)\n\ndt = DataTreatment(df, :reducesize; \n                   win=(win,), \n                   features=features)\n\n# Access processed data\nX_flat = get_dataset(dt)        # Flat feature matrix\nfeature_ids = get_featureid(dt) # Feature metadata\n\n# All parameters are stored for reproducibility\naggrtype = get_aggrtype(dt)     # :reducesize\nreduction = get_reducefunc(dt)   # mean (default)\nvar_names = get_vnames(dt)       # [:channel1, :channel2, :channel3]\nfeat_funcs = get_features(dt)    # (mean, std, maximum, minimum, median)\nn_windows = get_nwindows(dt)     # 6\n\n# Document experiment\nprintln(\"Processing: $aggrtype mode\")\nprintln(\"Variables: $(join(var_names, \", \"))\")\nprintln(\"Features: $(join(nameof.(feat_funcs), \", \"))\")\nprintln(\"Windows: $n_windows per dimension\")","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#Windowing-Functions-2","page":"Home","title":"Windowing Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"splitwindow(; nwindows::Int) - Equal non-overlapping windows\nmovingwindow(; winsize::Int, winstep::Int) - Fixed-size sliding windows\nadaptivewindow(; nwindows::Int, overlap::Float64) - Windows with overlap\nwholewindow() - Single window covering entire dimension","category":"page"},{"location":"#Processing-Functions","page":"Home","title":"Processing Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"applyfeat(X, intervals; reducefunc=mean) - Apply reduction to single array\naggregate(X, intervals; features=(mean,)) - Apply features to dataset elements\nreducesize(X, intervals; features=(mean,)) - Flatten to tabular format","category":"page"},{"location":"#Data-Structures-2","page":"Home","title":"Data Structures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataTreatment - Container for processed data with complete metadata\nFeatureId - Metadata for individual features (variable, function, window)","category":"page"},{"location":"#Accessor-Functions","page":"Home","title":"Accessor Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"get_dataset(dt) - Extract processed feature matrix\nget_featureid(dt) - Get feature metadata vector\nget_reducefunc(dt) - Get reduction function used\nget_aggrtype(dt) - Get processing mode\nget_vnames(dt) - Get unique variable names\nget_features(dt) - Get unique feature functions\nget_nwindows(dt) - Get maximum window number\nget_vname(fid) - Get variable name from FeatureId\nget_feature(fid) - Get feature function from FeatureId\nget_nwin(fid) - Get window number from FeatureId","category":"page"},{"location":"#Macros","page":"Home","title":"Macros","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@evalwindow(X, winfuncs...) - Evaluate window functions for array dimensions","category":"page"},{"location":"#Use-Cases","page":"Home","title":"Use Cases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Audio Processing: Extract features from spectrograms for audio classification\nImage Analysis: Process image patches for computer vision tasks\nTime Series: Analyze segmented multivariate time series\nSignal Processing: Extract statistical features from signal windows\nMedical Data: Process multi-channel physiological signals\nExperiment Reproducibility: All parameters stored for exact replication","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Developed by the ACLAI Lab @ University of Ferrara.","category":"page"}]
}
