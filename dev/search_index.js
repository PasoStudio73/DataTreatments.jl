var documenterSearchIndex = {"docs":
[{"location":"api/#dtattreatments","page":"Api","title":"DataTreatments","text":"","category":"section"},{"location":"api/#windowing","page":"Api","title":"Windowing","text":"","category":"section"},{"location":"api/#DataTreatments.FeatureId","page":"Api","title":"DataTreatments.FeatureId","text":"FeatureId <: AbstractFeatureId\n\nA metadata container for individual features in a processed dataset.\n\nThis struct stores information about each feature column, including the source variable name, the transformation function applied, and the window number. It is designed for:\n\nExperiment documentation: All feature extraction parameters are preserved for reproducibility\nFeature selection: Metadata enables intelligent feature filtering and selection strategies\nTraceability: Each feature can be traced back to its source variable and transformation\n\nFields\n\nvname::Symbol: Source variable name from the original dataset\nfeat::Base.Callable: Feature extraction function (e.g., mean, std, maximum)\nnwin::Int64: Window number (1 for single window, >1 for multiple windows)\n\nExamples\n\n# Single window feature\nfid = FeatureId(:temperature, mean, 1)\n# Displays as: mean(temperature)\n\n# Multi-window feature\nfid = FeatureId(:pressure, maximum, 3)\n# Displays as: maximum(pressure)_w3\n\n# Access metadata\nget_vname(fid)    # :pressure\nget_feat(fid)  # maximum\nget_nwin(fid)     # 3\n\nSee Also\n\nDataTreatment: Main container using FeatureId for metadata\n\n\n\n\n\n","category":"type"},{"location":"api/#DataTreatments.DataTreatment","page":"Api","title":"DataTreatments.DataTreatment","text":"DataTreatment{T, S} <: AbstractDataTreatment\n\nA container for processed multidimensional data with complete metadata for reproducibility.\n\nThis struct stores the transformed dataset along with all processing parameters, ensuring full experiment documentation and reproducibility.\n\nFields\n\ndataset::AbstractMatrix{T}: Processed flat feature matrix (samples Ã— features)\nfeatureid::Vector{FeatureId}: Metadata for each feature column (enables feature selection)\nreducefunc::Base.Callable: Reduction function used (for :reducesize mode)\naggrtype::Symbol: Processing type (:aggregate or :reducesize)\n\nType Parameters\n\nT: Element type of the output dataset\nS: Core element type for nested structures\n\nConstructor\n\nDataTreatment(\n    X::Union{AbstractMatrix, AbstractDataFrame},\n    aggrtype::Symbol;\n    vnames::Vector{<:NameTypes},\n    win::Union{Base.Callable, Tuple{Vararg{Base.Callable}}},\n    features::Tuple{Vararg{Base.Callable}}=(maximum, minimum, mean),\n    reducefunc::Base.Callable=mean,\n    groups::Union{Tuple{Vararg{Symbol}},Nothing}=nothing,\n    norm::Union{NormSpec,Type{<:AbstractNormalization},Nothing}=nothing\n)\n\nArguments\n\nX: Input data (Matrix or DataFrame with multidimensional elements)\naggrtype: Processing mode (:aggregate or :reducesize)\nvnames: Variable names for feature identification\nwin: Window function(s) for data partitioning\nfeatures: Tuple of statistical functions to apply (default: (maximum, minimum, mean))\nreducefunc: Reduction function for :reducesize mode (default: mean)\n\nProcessing Modes\n\n:aggregate Mode\n\nTransforms the dataset from multi-dimensional to tabular format.\n\nThe dataset is windowed to reduce its dimensionality\nReduction functions from the features parameter are applied to each window (default: mean, maximum)\n\nXmatrix = fill(rand(200, 120), 100, 10)  # 100 samples, 10 variables\nwin = splitwindow(nwindows=4)\nfeatures = (mean, std, maximum)\n\ndt = DataTreatment(Xmatrix, :aggregate;\n                   win, \n                   features)\n# Returns 100Ã—(10Ã—3Ã—16) = 100Ã—480 flat matrix\n# 10 vars Ã— 3 features Ã— 16 windows (4Ã—4 grid)\n\n:reducesize Mode\n\nReduces the dataset dimensionality by windowing.\n\nOnce windowed, a reduction function called reducefunc (default: mean) is applied to each window\nNote: it is still possible to specify features as in :aggregate, but these will simply be saved for future use (as in modal algorithms like ModalDecisionTrees)\n\nXmatrix = fill(rand(200, 120), 100, 10)  # 100 samples, 10 variables\nwin = splitwindow(nwindows=4)\nfeatures = (mean, std, maximum)\n\ndt = DataTreatment(Xmatrix, :reducesize;\n                   win, \n                   features)\n# Each 200Ã—120 element becomes 4Ã—4, resulting in 100Ã—10 output\n\nGrouping\n\ngroups Parameter\n\nOptional parameter to group dataset elements before processing.\n\nAccepts a tuple of symbols specifying grouping columns\nCreates logical groups within the dataset for separate processing\nCommon grouping strategies: (:vname,), (:vname, :feat), (:vname, :timestamp)\n\nXmatrix = [rand(1:100, 4, 2) for _ in 1:10, _ in 1:5]  # 10Ã—5 dataset where each element is a 4Ã—2 matrix\nvnames = Symbol.(\"auto\", 1:5)\n\ndt = DataTreatment(Xmatrix, :aggregate;\n                   win=splitwindow(nwindows=2),\n                   features=(mean, maximum),\n                   groups=(:vname, :feat))\n# Processes each (vname, feat) group independently\n\nNormalization\n\nnorm Parameter\n\nOptional normalization function to apply during processing.\n\nAccepts a normalization function (e.g., zscore, minmax, center)\nApplied after windowing and feature reduction\nCan be created with keyword arguments for customization\n\n# Min-max normalization with custom range\ndt = DataTreatment(Xmatrix, :aggregate;\n                   win=splitwindow(nwindows=2),\n                   features=(mean, maximum),\n                   norm=MinMax)\n\n# Z-score robust normalization\ndt = DataTreatment(Xmatrix, :aggregate;\n                   win=splitwindow(nwindows=2),\n                   features=(mean, maximum),\n                   norm=ZScore(method=:robust))\n\nGrouped Normalization\n\nWhen using groups with norm, never specify dims parameter.\n\nGrouped normalization works on all elements of each group as a whole\nThe dims parameter should NOT be used: it operates column-wise or row-wise, which breaks group semantics\nEach group is normalized independently using all its data\n\n# CORRECT: Grouped normalization without dims\n# groups = DataTreatments.groupby(X, [[:var1, :var2]])\n# normalized = DataTreatments.normalize(groups, UnitPower)\n# Each group normalized using all its elements\n\n# INCORRECT: Do not use dims with grouped normalization\n# normalized = DataTreatments.normalize(groups, UnitPower(dims=2))\n# This breaks the group semantics!\n\nAccessor Functions\n\nget_dataset(dt): Extract the processed feature matrix\nget_featureid(dt): Get feature metadata vector\nget_reducefunc(dt): Get the reduction function used\nget_aggrtype(dt): Get the processing mode\nget_groups(dt): Get grouped items\nget_norm(dt): Get normalization technique\nget_vnames(dt): Get unique variable names\nget_features(dt): Get unique feature functions\nget_nwindows(dt): Get maximum window number\n\nSee Also\n\nFeatureId: Individual feature metadata\n@evalwindow: Window evaluation macro\n\n\n\n\n\n","category":"type"},{"location":"api/#DataTreatments.movingwindow","page":"Api","title":"DataTreatments.movingwindow","text":"movingwindow(; winsize::Int64[, winstep::Int64]) -> Function\n\nCreates a moving (sliding) window function with fixed window size and step.\n\nKeyword Arguments\n\nwinsize::Int64: Size of each window\nwinstep::Int64: Step between consecutive windows (defaults to winsize if 0)\n\nReturns\n\nFunction: A function that takes npoints::Int64 and returns Vector{UnitRange{Int64}}\n\nExample\n\nwfunc = movingwindow(winsize=10, winstep=5)\nwindows = wfunc(100)  # apply to sequence of length 100\n\nUse with macro\n\nA = rand(200)\nwindows = @evalwindow A movingwindow(winsize=10, winstep=5)\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.wholewindow","page":"Api","title":"DataTreatments.wholewindow","text":"wholewindow() -> Function\n\nCreates a window function that returns a single window covering the entire sequence.\n\nReturns\n\nFunction: A function that takes npoints::Int64 and returns a single window [1:npoints]\n\nExample\n\nwfunc = wholewindow()\nwindows = wfunc(100)  # returns [1:100]\n\nUse with macro\n\nA = rand(200)\nwindows = @evalwindow A wholewindow()\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.splitwindow","page":"Api","title":"DataTreatments.splitwindow","text":"splitwindow(; nwindows::Int64) -> Function\n\nCreates a window function that splits the sequence into a fixed number of non-overlapping windows.\n\nKeyword Arguments\n\nnwindows::Int64: Number of windows to create\n\nReturns\n\nFunction: A function that takes npoints::Int64 and returns Vector{UnitRange{Int64}}\n\nExample\n\nwfunc = splitwindow(nwindows=5)\nwindows = wfunc(100)  # splits into 5 equal windows\n\nUse with macro\n\nA = rand(200)\nwindows = @evalwindow A splitwindow(nwindows=5)\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.adaptivewindow","page":"Api","title":"DataTreatments.adaptivewindow","text":"adaptivewindow(; nwindows::Int64[, overlap::Float64=0.0]) -> Function\n\nCreates a window function that adaptively divides the sequence into windows with optional overlap.\n\nKeyword Arguments\n\nnwindows::Int64: Number of windows to create\noverlap::Float64: Relative overlap between windows (0.0 to 1.0), defaults 0.0.\n\nReturns\n\nFunction: A function that takes npoints::Int64 and returns Vector{UnitRange{Int64}}\n\nExample\n\nwfunc = adaptivewindow(nwindows=5, overlap=0.2)\nwindows = wfunc(100)  # 5 windows with 20% overlap\n\nUse with macro\n\nA = rand(200)\nwindows = @evalwindow A adaptivewindow(nwindows=5, overlap=0.2)\n\n\n\n\n\n","category":"function"},{"location":"api/#DataTreatments.@evalwindow","page":"Api","title":"DataTreatments.@evalwindow","text":"@evalwindow(X, winfuncs...) -> Tuple{Vararg{Vector{UnitRange{Int64}}}}\n\nApply window functions to each dimension of an array.\n\nThis macro evaluates window functions for each dimension of an array, automatically  determining the appropriate number of points from the array's size. If fewer window  functions are provided than dimensions, the last function is reused for remaining dimensions.\n\nArguments\n\nX: Input array whose dimensions determine window parameters\nwinfuncs...: One or more window functions (e.g., movingwindow(), splitwindow(), adaptivewindow())\n\nReturns\n\nTuple{Vararg{Vector{UnitRange{Int64}}}}: Tuple of vectors containing window ranges for each dimension\n\nBehavior\n\nEach window function is applied to the corresponding dimension size\nIf length(winfuncs) < ndims(X), the last function is repeated for remaining dimensions\nWindow functions must be created using movingwindow, splitwindow, adaptivewindow, or wholewindow\n\nExamples\n\nSingle dimension\n\nX = rand(200)\nwindows = @evalwindow X movingwindow(winsize=50, winstep=25)\n\nTwo dimensions with different windows\n\nX = rand(200, 120)\nwindows = @evalwindow X splitwindow(nwindows=4) adaptivewindow(nwindows=3, overlap=0.1)\n# First dimension: 4 non-overlapping windows\n\nReusing window function for multiple dimensions\n\nX = rand(100, 120, 80)\nwindows = @evalwindow X splitwindow(nwindows=5)\n\nSee Also\n\nmovingwindow: Fixed-size sliding windows\nsplitwindow: Equal non-overlapping windows\nadaptivewindow: Windows with overlap\nwholewindow: Single window covering entire dimension\n\n\n\n\n\n","category":"macro"},{"location":"featureset/#featuresets","page":"FeatureSet","title":"Featuresets","text":"","category":"section"},{"location":"featureset/#Basic-Statistics","page":"FeatureSet","title":"Basic Statistics","text":"Standard statistical measures: maximum, minimum, mean, median, std, cov","category":"section"},{"location":"featureset/#Catch22-Features","page":"FeatureSet","title":"Catch22 Features","text":"Canonical time-series characteristics covering:\n\nDistribution properties and extreme events\nLinear and nonlinear autocorrelation structures  \nForecasting performance and scaling properties\nSymbolic dynamics and transition patterns","category":"section"},{"location":"featureset/#Predefined-Feature-Sets","page":"FeatureSet","title":"Predefined Feature Sets","text":"base_set: Minimal statistical features (4 features)\ncatch9: Curated subset combining statistics + key Catch22 (9 features)  \ncatch22_set: Complete Catch22 suite (22 features)\ncomplete_set: All features combined (28 features)","category":"section"},{"location":"featureset/#References","page":"FeatureSet","title":"References","text":"The Catch22 features are based on the Canonical Time-series Characteristics:\n\nRepository: https://github.com/DynamicsAndNeuralSystems/catch22\nPaper: Lubba, C.H., Sethi, S.S., Knaute, P. et al. \"catch22: CAnonical Time-series CHaracteristics.\" Data Min Knowl Disc 33, 1821â€“1852 (2019). https://doi.org/10.1007/s10618-019-00647-x","category":"section"},{"location":"featureset/#All-Catch22-Features","page":"FeatureSet","title":"All Catch22 Features","text":"","category":"section"},{"location":"featureset/#DataTreatments.base_set","page":"FeatureSet","title":"DataTreatments.base_set","text":"base_set\n\nA minimal feature set containing only basic statistical measures for time series analysis.\n\nFeatures\n\nmaximum: Maximum value in the time series\nminimum: Minimum value in the time series  \nmean   : Arithmetic mean of the time series\nstd    : Standard deviation of the time series\n\n\n\n\n\n","category":"constant"},{"location":"featureset/#DataTreatments.catch9","page":"FeatureSet","title":"DataTreatments.catch9","text":"catch9\n\nA curated subset of 9 features combining basic statistics with Symbolic Catch22 measures,\n\nFeatures\n\nBasic statistics: maximum, minimum, mean, median, std\nSymbolic Catch22 features:\nstretch_high       : Measures persistence of high values\nstretch_decreasing : Captures decreasing trend patterns\nentropy_pairs      : Quantifies local pattern complexity\ntransition_variance: Measures state transition variability\n\nReferences\n\nThe Catch22 features are based on the CAnonical Time-series CHaracteristics from:\n\nRepository: https://github.com/DynamicsAndNeuralSystems/catch22\nArticle:    https://doi.org/10.1007/s10618-019-00647-x\nAuthor: Carl H. Lubba et al\n\n\n\n\n\n","category":"constant"},{"location":"featureset/#DataTreatments.catch22_set","page":"FeatureSet","title":"DataTreatments.catch22_set","text":"catch22_set\n\nThe complete Catch22 feature set. Each feature captures different aspects of time series dynamics including correlation structure, distribution properties and temporal patterns.\n\nFeature Categories\n\nDistribution shape:  mode_5, mode_10\nExtreme event timing: outlier_timing_pos, outlier_timing_neg\nLinear autocorrelation: acf_timescale, acf_first_min, low_freq_power, centroid_freq\nSimple forecasting: forecast_error\nIncremental differences: whiten_timescale, high_fluctuation\nSymbolic stretch_high, stretch_decreasing, entropy_pairs, transition_variance\nNonlinear autocorrelation: ami2, trev\nLinear autocorrelation structure: ami_timescale, periodicity\nSelf-affine scaling: rs_range, dfa\nOther: embedding_dist\n\nReferences\n\nThe Catch22 features are based on the CAnonical Time-series CHaracteristics from:\n\nRepository: https://github.com/DynamicsAndNeuralSystems/catch22\nArticle:    https://doi.org/10.1007/s10618-019-00647-x\nAuthor: Carl H. Lubba et al\n\n\n\n\n\n","category":"constant"},{"location":"featureset/#DataTreatments.complete_set","page":"FeatureSet","title":"DataTreatments.complete_set","text":"complete_set\n\nThe most comprehensive feature set combining basic statistical measures, covariance analysis, and the full Catch22 suite.\n\nFeatures\n\nBasic statistics: maximum, minimum, mean, median, std, cov\nDistribution shape:  mode_5, mode_10\nExtreme event timing: outlier_timing_pos, outlier_timing_neg\nLinear autocorrelation: acf_timescale, acf_first_min, low_freq_power, centroid_freq\nSimple forecasting: forecast_error\nIncremental differences: whiten_timescale, high_fluctuation\nSymbolic stretch_high, stretch_decreasing, entropy_pairs, transition_variance\nNonlinear autocorrelation: ami2, trev\nLinear autocorrelation structure: ami_timescale, periodicity\nSelf-affine scaling: rs_range, dfa\nOther: embedding_dist\n\n\n\n\n\n","category":"constant"},{"location":"featureset/#DataTreatments.mode_5","page":"FeatureSet","title":"DataTreatments.mode_5","text":"DN_HistogramMode_5(x::AbstractVector{Union{Float64, Int}}) # For example\n\nAn alternative to catch22(:DN_HistogramMode_5](x). All features, such as DN_HistogramMode_5, are exported as Features and can be evaluated by calling their names.\n\nExamples\n\nð± = Catch22.testdata[:test]\nf = DN_HistogramMode_5(ð±)\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.mode_10","page":"FeatureSet","title":"DataTreatments.mode_10","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.embedding_dist","page":"FeatureSet","title":"DataTreatments.embedding_dist","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.acf_timescale","page":"FeatureSet","title":"DataTreatments.acf_timescale","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.acf_first_min","page":"FeatureSet","title":"DataTreatments.acf_first_min","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.ami2","page":"FeatureSet","title":"DataTreatments.ami2","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.trev","page":"FeatureSet","title":"DataTreatments.trev","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.outlier_timing_pos","page":"FeatureSet","title":"DataTreatments.outlier_timing_pos","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.outlier_timing_neg","page":"FeatureSet","title":"DataTreatments.outlier_timing_neg","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.whiten_timescale","page":"FeatureSet","title":"DataTreatments.whiten_timescale","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.forecast_error","page":"FeatureSet","title":"DataTreatments.forecast_error","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.ami_timescale","page":"FeatureSet","title":"DataTreatments.ami_timescale","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.high_fluctuation","page":"FeatureSet","title":"DataTreatments.high_fluctuation","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.stretch_decreasing","page":"FeatureSet","title":"DataTreatments.stretch_decreasing","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.stretch_high","page":"FeatureSet","title":"DataTreatments.stretch_high","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.entropy_pairs","page":"FeatureSet","title":"DataTreatments.entropy_pairs","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.rs_range","page":"FeatureSet","title":"DataTreatments.rs_range","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.dfa","page":"FeatureSet","title":"DataTreatments.dfa","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.low_freq_power","page":"FeatureSet","title":"DataTreatments.low_freq_power","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.centroid_freq","page":"FeatureSet","title":"DataTreatments.centroid_freq","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.transition_variance","page":"FeatureSet","title":"DataTreatments.transition_variance","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"featureset/#DataTreatments.periodicity","page":"FeatureSet","title":"DataTreatments.periodicity","text":"No documentation found for public binding TimeseriesFeatures.SuperFeatures.SuperFeature.\n\nSummary\n\nstruct TimeseriesFeatures.SuperFeatures.SuperFeature{F, G}\n\nFields\n\nfeature     :: F\nsuper       :: G\nname        :: Symbol\ndescription :: String\nkeywords    :: Vector{String}\n\nSupertype Hierarchy\n\nTimeseriesFeatures.SuperFeatures.SuperFeature{F, G} <: TimeseriesFeatures.SuperFeatures.AbstractSuperFeature <: TimeseriesFeatures.Features.AbstractFeature <: Function <: Any\n\n\n\n\n\n","category":"function"},{"location":"normalization/#Normalization","page":"Normalization","title":"Normalization","text":"DataTreatments.jl delegates normalization logic to the external package Normalization.jl.\n\nIn practice:\n\ncore normalization algorithms are provided by Normalization.jl;\nDataTreatments.jl re-exports the main normalization API (fit, fit!, normalize, normalize!);\nDataTreatments.jl adds integration for nested/multidimensional dataset elements via its extension layer (ext/NormalizationExt.jl);\nNormSpec is the local convenience wrapper used to configure normalization type + dims.","category":"section"},{"location":"normalization/#Notes-on-dims","page":"Normalization","title":"Notes on dims","text":"dims supports:\n\nnothing: global fit on all values,\n1: column-wise,\n2: row-wise.\n\nWhen using grouped processing (groups=... in DataTreatment), keep normalization semantics consistent with grouping logic.","category":"section"},{"location":"normalization/#Examples","page":"Normalization","title":"Examples","text":"using DataTreatments\n\nX = [rand(4, 2) for _ in 1:10, _ in 1:5]\n\n# Build a normalization spec in DataTreatments\nns = ZScore(dims=1, method=:std)\n\n# Apply normalization (delegated to Normalization.jl + DataTreatments extension)\nY = normalize(X, ns)","category":"section"},{"location":"normalization/#References","page":"Normalization","title":"References","text":"Normalization.jl package documentation and source code.\nDataTreatments.jl extension module: ext/NormalizationExt.jl.\nDataTreatments.jl normalization spec definitions: src/normalize.jl.","category":"section"},{"location":"normalization/#Acknowledgements","page":"Normalization","title":"Acknowledgements","text":"We thank the maintainers and contributors of Normalization.jl for providing the core normalization framework used by DataTreatments.jl.","category":"section"},{"location":"treatment/#datatreatment","page":"DataTreatment","title":"DataTreatment","text":"","category":"section"},{"location":"treatment/#What-is-a-data-treatment?","page":"DataTreatment","title":"What is a data treatment?","text":"DataTreatments.jl provides tools for manipulating and analyzing multidimensional datasets, meaning datasets whose elements are not single numbers but signals (e.g., audio or time-series sensor inputs) or higherâ€‘dimensional structures (e.g., images and beyond).","category":"section"},{"location":"treatment/#Why-is-data-treatment-necessary?","page":"DataTreatment","title":"Why is data treatment necessary?","text":"Multidimensional data such as audio or images often have very large sizes due to high resolution. In many cases, we cannot perform analysis or machine learning directly on such large data. Therefore, dataâ€‘compression algorithms are useful to reduce dimensionality while minimizing information loss.\n\nOne of the most widely used approaches is windowing.","category":"section"},{"location":"treatment/#Two-common-scenarios","page":"DataTreatment","title":"Two common scenarios","text":"reducesize   The output dataset keeps the same overall structure as the input, but with smaller elements.\nExample (reducesize):\nusing DataTreatments\n\nX = [rand(4) for _ in 1:3, _ in 1:2]\n\nvnames = [:ch1, :ch2];\nwin = splitwindow(nwindows=2);\nfeatures = (mean, maximum);\n\ndt_rs = DataTreatment(X, :reducesize; vnames, win, features);\n\nget_dataset(dt_rs)\naggregate   The dataset is resized and also transformed into a tabular dataset, where windows become consecutive columns in the output.\nExample (reducesize):\nusing DataTreatments\n\nX = [rand(4) for _ in 1:2, _ in 1:2]\n\nvnames = [:ch1, :ch2];\nwin = splitwindow(nwindows=2);\nfeatures = (mean,);\n\ndt_ag = DataTreatment(X, :aggregate; vnames, win, features);\n\nget_dataset(dt_ag)\nget_featureid(dt_ag)","category":"section"},{"location":"treatment/#Note","page":"DataTreatment","title":"Note","text":"Windowing is especially useful for normalizing datasets whose elements have different sizes (common with audio files). By using a fixed number of windows, object sizes are normalized and subsequent analysis becomes more reliable.","category":"section"},{"location":"grouping/#grouping","page":"Grouping","title":"Grouping","text":"","category":"section"},{"location":"grouping/#Why-group-features?","page":"Grouping","title":"Why group features?","text":"Often you work with datasets whose columns have different units of measurement. A simple example is a medical dataset where we have audio files together with recordings of electromagnetic pulses.\n\nSeveral machine learning algorithms explicitly require the input data to be normalized (typically in a 0â€“1 range). We could normalize column by column, but this risks flattening the dataset with a consequent loss of information.\n\nThat is why the possibility to group columns according to a certain logic is useful.\n\nThe DataTreatments package provides this functionality not only for multidimensional datasets, but also for tabular datasets.","category":"section"},{"location":"grouping/#DataTreatments.groupby-Tuple{DataTreatment, Vararg{Symbol}}","page":"Grouping","title":"DataTreatments.groupby","text":"groupby(data::DataTreatment, fields...)\n\nGroup rows in a DataTreatment dataset by one or more feature attributes.\n\nPurpose\n\nThe groupby function enables hierarchical grouping of DataTreatment columns based on  feature properties stored in the FeatureId structure. This is essential for operations  that require consistent computation across groups rather than column-by-column, preventing  data inconsistencies and unwanted flattening.\n\nFeatureId Structure\n\nEach feature in the dataset carries metadata through its FeatureId:\n\nvname: The name/identifier of the feature\nnwin: The window number associated with multidimensional levels\nfeat: The feature used to reduce or aggregate multidimensional elements to  manageable computational size\n\nUse Cases\n\nNormalization Across Groups\n\nInstead of normalizing column-by-column (which can flatten or damage the dataset),  you can compute normalization coefficients spanning an entire group, ensuring  consistent scaling across related features.\n\nExample: Normalize all channels of a multi-channel sensor reading together,  rather than independently per channel.\n\nMulti-Level Grouping\n\nGroup hierarchically by multiple attributes (e.g., first by feature name, then by  window, then by reduction method) for complex data analysis pipelines.\n\nReturns\n\nTuple of:\n\ngroups: Vector of index groups mapping to original dataset positions\nfeat_groups: Corresponding FeatureId groups for each group of indices\n\n\n\n\n\n","category":"method"},{"location":"grouping/#DataTreatments.groupby-Tuple{DataFrames.DataFrame, Vector{Vector{Symbol}}}","page":"Grouping","title":"DataTreatments.groupby","text":"groupby(df::DataFrame, fields::Vector{Vector{Symbol}})\n\nGroup DataFrame columns into multiple sub-DataFrames based on pre-defined column groups.\n\nArguments\n\ndf: Source DataFrame.\nfields: Vector of column-name vectors (each inner vector is one group).\n\nBehavior\n\nComputes any leftover columns not listed in fields and appends them as a final group.\nReturns a Vector{DataFrame} where each element is df[!, fields[i]].\n\nExample\n\nusing DataFrames\n\ndf = DataFrame(\n    sepal_length = rand(3),\n    sepal_width  = rand(3),\n    petal_length = rand(3),\n    petal_width  = rand(3),\n)\n\nfields = [[:sepal_length, :petal_length], [:sepal_width]]\ngroups = groupby(df, fields)\n\n\n\n\n\n","category":"method"},{"location":"#DataTreatments.jl","page":"Home","title":"DataTreatments.jl","text":"A Julia package for processing datasets containing multidimensional elements through windowing and dimensionality reduction techniques.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"DataTreatments.jl provides tools for working with matrices, or DataFrames where each element is itself a multidimensional object (vectors, matrices, or higher-dimensional arrays). It offers:\n\nWindowing functions for partitioning multidimensional data\nDimensionality reduction using feature extraction together with windowing\nTabular transformation through feature extraction to convert complex multidimensional datasets into flat feature matrices suitable for standard machine learning models\nData normalization with multiple methods (z-score, min-max, sigmoid, etc.) for preprocessing\nGroup-wise operations via groupby for consistent processing across related features\nComplete reproducibility by storing all processing parameters and feature metadata\n\nThis package is particularly useful when you need to apply traditional ML algorithms that require tabular input to datasets containing structured multidimensional elements like images, spectrograms, or time series segments.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"DataTreatments\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-Usage-with-Matrix","page":"Home","title":"Basic Usage with Matrix","text":"using DataTreatments\n\n# Create a dataset with multidimensional elements\nXmatrix = [rand(1:100, 4, 2) for _ in 1:10, _ in 1:5]  # 10Ã—5 dataset where each element is a 4Ã—2 matrix\nvnames = Symbol.(\"auto\", 1:5)\n\n# Define processing parameters\nwin = splitwindow(nwindows=2)\nfeatures = (mean, std, maximum, minimum)\nnorm = ZScore\nreducefunc = median\n\n# Process for propositional analysis\nresult = DataTreatment(Xmatrix, :aggregate; vnames, win, features, norm)\n\n# Process for modal analysis\nresult = DataTreatment(Xmatrix, :reducesize; vnames, win, features, reducefunc, norm)","category":"section"},{"location":"#Basic-Usage-with-DataFrame","page":"Home","title":"Basic Usage with DataFrame","text":"using DataTreatments\nusing DataFrames\n\n# Create dataset with multidimensional elements\ndf = DataFrame(\n    channel1 = [rand(200, 120) for _ in 1:1000],\n    channel2 = [rand(200, 120) for _ in 1:1000],\n    channel3 = [rand(200, 120) for _ in 1:1000]\n)\n\n# Define processing parameters\nwin = adaptivewindow(nwindows=6, overlap=0.15)\nfeatures = (mean, std, maximum, minimum, median)\nnorm = PNorm(p=1)\nreducefunc = median\n\n# Process for propositional analysis\nresult = DataTreatment(df, :aggregate; win, features, norm)\n\n# Process for modal analysis\nresult = DataTreatment(df, :reducesize; win, features, reducefunc, norm)\n\n# Access processed data\nX_flat = get_dataset(result)        # Flat feature matrix\nfeature_ids = get_featureid(result) # Feature metadata","category":"section"},{"location":"#Core-Concepts","page":"Home","title":"Core Concepts","text":"","category":"section"},{"location":"#Windowing-Functions","page":"Home","title":"Windowing Functions","text":"DataTreatments provides several windowing strategies:","category":"section"},{"location":"#splitwindow-Equal-Non-Overlapping-Windows","page":"Home","title":"splitwindow - Equal Non-Overlapping Windows","text":"win = splitwindow(nwindows=3)\n# Divides data into 3 equal, non-overlapping segments","category":"section"},{"location":"#movingwindow-Fixed-Size-Sliding-Windows","page":"Home","title":"movingwindow - Fixed-Size Sliding Windows","text":"win = movingwindow(winsize=50, winstep=25)\n# Creates overlapping windows of size 50, advancing by 25 points","category":"section"},{"location":"#adaptivewindow-Windows-with-Controlled-Overlap","page":"Home","title":"adaptivewindow - Windows with Controlled Overlap","text":"win = adaptivewindow(nwindows=5, overlap=0.2)\n# Creates 5 windows with 20% overlap between consecutive windows","category":"section"},{"location":"#wholewindow-Single-Window-(Entire-Dimension)","page":"Home","title":"wholewindow - Single Window (Entire Dimension)","text":"win = wholewindow()\n# Creates a single window covering the entire dimension","category":"section"},{"location":"#Multi-Dimensional-Windowing","page":"Home","title":"Multi-Dimensional Windowing","text":"Use the @evalwindow macro to apply window functions to each dimension:\n\nX = rand(200, 120)\n\n# Apply same windowing to all dimensions\nintervals = @evalwindow X splitwindow(nwindows=4)\n\n# Apply different windowing per dimension\nintervals = @evalwindow X splitwindow(nwindows=4) movingwindow(winsize=40, winstep=20)","category":"section"},{"location":"#Normalization","page":"Home","title":"Normalization","text":"DataTreatments.jl uses Normalization.jl as its normalization backend.\n\nCore normalization algorithms are provided by Normalization.jl.\nDataTreatments.jl re-exports fit, fit!, normalize, and normalize!.\nDataTreatments.jl adds integration for nested/multidimensional dataset elements in ext/NormalizationExt.jl.\nNormSpec provides a package-local convenience interface for selecting normalization type and dims.\n\nWe thank the maintainers and contributors of Normalization.jl for their work and for making this integration possible.","category":"section"},{"location":"#Grouping-Functions","page":"Home","title":"Grouping Functions","text":"Grouping lets you partition related feature columns (e.g., by variable name, window, or feature) so that operations like normalization are applied with shared coefficients across each group instead of per-column. This preserves consistent scaling for semantically related parts of the dataset.\n\ndt = DataFrame([rand(1:100, 4, 2) for _ in 1:10, _ in 1:5], :auto)\nwin = splitwindow(nwindows=2)\n\ngrp1 = [:x1, :x2]\ngroups = DataTreatments.groupby(dt, grp1)\ndt_norm = DataTreatment(dt, :aggregate; win, features, groups=(:vname,), norm=ZScore)","category":"section"},{"location":"#Data-Structures","page":"Home","title":"Data Structures","text":"","category":"section"},{"location":"#FeatureId-Feature-Metadata","page":"Home","title":"FeatureId - Feature Metadata","text":"A metadata container that stores information about each feature column for reproducibility and feature selection:\n\n# Created automatically by DataTreatment\ndt = DataTreatment(df, :reducesize; win=(win,), features=(mean, std, maximum))\n\n# Access feature metadata\nfeature_ids = get_featureid(dt)\n\n# Each FeatureId contains:\n# - vname: Source variable name\n# - feat: Feature function applied\n# - nwin: Window number","category":"section"},{"location":"#DataTreatment-Complete-Processing-Container","page":"Home","title":"DataTreatment - Complete Processing Container","text":"A comprehensive container that stores processed data along with all parameters for full reproducibility:\n\n# Create dataset\ndf = DataFrame(\n    channel1 = [rand(200, 120) for _ in 1:1000],\n    channel2 = [rand(200, 120) for _ in 1:1000],\n    channel3 = [rand(200, 120) for _ in 1:1000]\n)\n\n# Process with full parameter storage\nwin = adaptivewindow(nwindows=6, overlap=0.15)\nfeatures = (mean, std, maximum, minimum, median)\n\ndt = DataTreatment(df, :reducesize; win, features, norm=MinMax)\n\n# Access processed data\nX_flat = get_dataset(dt)        # Flat feature matrix\nfeature_ids = get_featureid(dt) # Feature metadata\n\n# All parameters are stored for reproducibility\naggrtype = get_aggrtype(dt)     # :reducesize\nreduction = get_reducefunc(dt)   # mean (default)\nvar_names = get_vnames(dt)       # [:channel1, :channel2, :channel3]","category":"section"},{"location":"#Use-Cases","page":"Home","title":"Use Cases","text":"Audio Processing: Extract features from spectrograms for audio classification\nImage Analysis: Process image patches for computer vision tasks\nTime Series: Analyze segmented multivariate time series\nSignal Processing: Extract statistical features from signal windows\nMedical Data: Process multi-channel physiological signals\nExperiment Reproducibility: All parameters stored for exact replication","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MIT License","category":"section"},{"location":"#About","page":"Home","title":"About","text":"Developed by the ACLAI Lab @ University of Ferrara.","category":"section"}]
}
