<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Normalization · DataTreatments.jl</title><meta name="title" content="Normalization · DataTreatments.jl"/><meta property="og:title" content="Normalization · DataTreatments.jl"/><meta property="twitter:title" content="Normalization · DataTreatments.jl"/><meta name="description" content="Documentation for DataTreatments.jl."/><meta property="og:description" content="Documentation for DataTreatments.jl."/><meta property="twitter:description" content="Documentation for DataTreatments.jl."/><meta property="og:url" content="https://PasoStudio73.github.io/DataTreatments.jl/normalization/"/><meta property="twitter:url" content="https://PasoStudio73.github.io/DataTreatments.jl/normalization/"/><link rel="canonical" href="https://PasoStudio73.github.io/DataTreatments.jl/normalization/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataTreatments.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">Api</a></li><li><a class="tocitem" href="../featureset/">FeatureSet</a></li><li class="is-active"><a class="tocitem" href>Normalization</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#dtattreatments"><span>Methods Api</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Normalization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Normalization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PasoStudio73/DataTreatments.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/main/docs/src/normalization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Normalization"><a class="docs-heading-anchor" href="#Normalization">Normalization</a><a id="Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="DataTreatments.element_norm"><a class="docstring-binding" href="#DataTreatments.element_norm"><code>DataTreatments.element_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">element_norm(X::AbstractArray, n::Base.Callable) -&gt; AbstractArray</code></pre><p>Normalize a single array element using global statistics computed across all elements.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractArray</code>: Input array of any dimension (vector, matrix, tensor, etc.)</li><li><code>n::Base.Callable</code>: Normalization function constructor that computes parameters from data</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">X = rand(100, 50)
X_norm = element_norm(X, zscore())      # Z-score normalization
X_norm = element_norm(X, minmax())     # Min-max scaling
X_norm = element_norm(X, center())      # Mean centering</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L422-L438">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.tabular_norm"><a class="docstring-binding" href="#DataTreatments.tabular_norm"><code>DataTreatments.tabular_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tabular_norm(X::AbstractArray, n::Base.Callable; [dim::Symbol=:col]) -&gt; AbstractArray</code></pre><p>Normalize a tabular array by computing separate normalization parameters for each column or row.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractArray</code>: Input array (typically a matrix where columns represent features)</li><li><code>n::Base.Callable</code>: Normalization function constructor (e.g., <code>zscore()</code>, <code>minmax()</code>)</li><li><code>dim::Symbol=:col</code>: Dimension along which to normalize<ul><li><code>:col</code> (default): Normalize each column independently (column-wise)</li><li><code>:row</code>: Normalize each row independently (row-wise)</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Column-wise normalization (default) - each feature normalized independently
X = rand(100, 50)  # 100 samples, 50 features
X_norm = tabular_norm(X, zscore())
# Each column: mean ≈ 0, std ≈ 1

# Row-wise normalization - each sample normalized independently
X_scaled = tabular_norm(X, minmax(); dim=:row)
# Each row scaled to [0, 1] independently</code></pre><p><strong>Notes</strong></p><ul><li>Each column/row uses only its own statistics, not global statistics</li><li>Automatically converts Real arrays to Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L446-L473">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.grouped_norm"><a class="docstring-binding" href="#DataTreatments.grouped_norm"><code>DataTreatments.grouped_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">grouped_norm(X::AbstractArray, n::Base.Callable; featvec::Vector) -&gt; AbstractArray</code></pre><p>Normalize grouped columns of a dataset by applying the same normalization coefficient to all columns generated by the same feature/transform.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractArray{&lt;:AbstractFloat}</code>: Tabular dataset (observations × features).</li><li><code>n::Base.Callable</code>: Normalization constructor (e.g. <code>zscore()</code>, <code>minmax()</code>).</li><li><code>featvec::Vector{&lt;:Base.Callable}</code>: Feature functions associated with each column in <code>X</code>. Columns sharing the same callable form a group and reuse the same normalization statistics.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Dataset with features from 2 variables and 2 transforms
X = rand(100, 4)  # 100 samples, 4 features
featvec = [mean, mean, std, std]  # First 2 cols are means, last 2 are stds

# Normalize: all mean-based columns share normalization, std-based share another
X_norm = grouped_norm(X, zscore(); featvec)
# Columns 1-2: normalized together (mean ≈ 0, std ≈ 1 across both)
# Columns 3-4: normalized together (mean ≈ 0, std ≈ 1 across both)

# With windowed features
win = splitwindow(nwindows=3)
features = (mean, maximum)
dt = DataTreatment(X_nested, :aggregate; win=(win,), features)
# Each variable produces 3×2=6 features: mean_w1, mean_w2, mean_w3, max_w1, max_w2, max_w3

X_grouped = grouped_norm(dt.dataset, minmax(); featvec=get_vecfeatures(dt.featureid))
# All mean features normalized together, all max features normalized together</code></pre><p><strong>Notes</strong></p><ul><li>Returns a new array; use <code>grouped_norm!</code> for in-place normalization</li><li>Columns are grouped by feature function identity</li><li>Each group computes normalization statistics from all values across its columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L490-L529">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.grouped_norm!"><a class="docstring-binding" href="#DataTreatments.grouped_norm!"><code>DataTreatments.grouped_norm!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">grouped_norm!(X::AbstractArray, n::Base.Callable; featvec::Vector) -&gt; Nothing</code></pre><p>In-place version of <a href="#DataTreatments.grouped_norm"><code>grouped_norm</code></a>. Modifies <code>X</code> directly by normalizing grouped  columns using the same normalization function for columns sharing the same feature type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L548-L553">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.ds_norm"><a class="docstring-binding" href="#DataTreatments.ds_norm"><code>DataTreatments.ds_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ds_norm(X::AbstractArray{&lt;:AbstractArray}, n::Base.Callable) -&gt; AbstractArray</code></pre><p>Normalize a dataset composed of n-dimensional elements (e.g., sequences, time series, or images) by computing normalization parameters for each column of the outer array.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractArray{&lt;:AbstractArray}</code>: Nested array structure where each element is an array<ul><li>Outer array typically represents (samples × features/channels)</li><li>Inner arrays can be vectors, matrices, or tensors</li></ul></li><li><code>n::Base.Callable</code>: Normalization function constructor (e.g., <code>zscore()</code>, <code>minmax()</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Time series dataset: each element is a time series
X = [rand(100) for _ in 1:50, _ in 1:3]  # 50 samples × 3 channels
X_norm = ds_norm(X, zscore())
# Each channel normalized across all 50 time series

# Image dataset: each element is an image (matrix)
images = [rand(28, 28) for _ in 1:100, _ in 1:1]  # 100 grayscale images
images_norm = ds_norm(images, minmax())
# All images normalized using global min/max</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L578-L602">source</a></section></details></article><h1 id="dtattreatments"><a class="docs-heading-anchor" href="#dtattreatments">Methods Api</a><a id="dtattreatments-1"></a><a class="docs-heading-anchor-permalink" href="#dtattreatments" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="DataTreatments.zscore"><a class="docstring-binding" href="#DataTreatments.zscore"><code>DataTreatments.zscore</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zscore(; [method::Symbol]) -&gt; Function
zscore(x::AbstractArray; kwargs...)</code></pre><p>Create a z-score normalization function that standardizes data by centering and scaling.</p><p><strong>Arguments</strong></p><ul><li><code>method::Symbol</code>: Method for computing the z-score</li></ul><p><strong>Methods</strong></p><p><strong>Standard Z-Score (<code>:std</code>, default)</strong></p><p>Centers data to mean 0 and scales to standard deviation 1.</p><p class="math-container">\[z = \frac{x - \mu}{\sigma}\]</p><p>where μ is the mean and σ is the standard deviation.</p><p><strong>Robust Z-Score (:robust)</strong></p><p>Centers data to median 0 and scales to median absolute deviation 1. More resistant to outliers than standard z-score.</p><p class="math-container">\[z = \frac{x - \text{median}(x)}{\text{MAD}(x)}\]</p><p>where MAD is the median absolute deviation.</p><p><strong>Half-Normal Z-Score (:half)</strong></p><p>Normalizes to the standard half-normal distribution using minimum and half-standard deviation.</p><p class="math-container">\[z = \frac{x - \min(x)}{\sigma_{\text{half}}}\]</p><p>where σ_half = σ / √(1 - 2/π).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Standard z-score normalization
X = rand(100, 50)
X_norm = element_norm(X, zscore())
# Result: mean ≈ 0, std ≈ 1

# Robust z-score (resistant to outliers)
X_robust = element_norm(X, zscore(method=:robust))
# Result: median ≈ 0, MAD ≈ 1

# Half-normal z-score
X_half = element_norm(X, zscore(method=:half))
# Result: minimum ≈ 0, scaled by half-standard deviation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L71-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.sigmoid"><a class="docstring-binding" href="#DataTreatments.sigmoid"><code>DataTreatments.sigmoid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sigmoid() -&gt; Function
sigmoid(x::AbstractArray)</code></pre><p>Create a sigmoid normalization function that maps data to the interval (0, 1).</p><p>The sigmoid (or logistic) function provides a smooth, S-shaped transformation that  maps the entire real line to the bounded interval (0, 1), with the steepest slope  at the mean of the data.</p><p><strong>Formula</strong></p><p class="math-container">\[\sigma(x) = \frac{1}{1 + e^{-\frac{x - \mu}{\sigma}}}\]</p><p>where:</p><ul><li>μ (mu) is the mean of the input data</li><li>σ (sigma) is the standard deviation of the input data</li><li>The output is bounded: 0 &lt; σ(x) &lt; 1</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Sigmoid normalization
X = rand(100, 50)
X_sigmoid = element_norm(X, sigmoid())
# Result: all values in (0, 1), mean(X) → 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L123-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.pnorm"><a class="docstring-binding" href="#DataTreatments.pnorm"><code>DataTreatments.pnorm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pnorm(; [p::Real]) -&gt; Function
pnorm(x::AbstractArray; kwargs...)</code></pre><p>Create a normalization function that scales data by the p-norm.</p><p>The p-norm normalization divides each element by the p-norm of the entire dataset, ensuring that the normalized data has unit p-norm. This is particularly useful for standardizing data magnitudes across different scales.</p><p><strong>Arguments</strong></p><ul><li><code>p::Real</code>: The norm order (default: 2)<ul><li><code>p = 1</code>: Manhattan norm (sum of absolute values)</li><li><code>p = 2</code>(default): Euclidean norm (default, root sum of squares)</li><li><code>p = Inf</code>: Infinity norm (maximum absolute value)</li><li><code>p &gt; 0</code>: General p-norm</li></ul></li></ul><p><strong>Formula</strong></p><p><strong>General p-norm (p ≥ 1):</strong></p><p class="math-container">\[\|x\|_p = \left(\sum_{i=1}^{n} |x_i|^p\right)^{1/p}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># L2 norm (Euclidean, default)
X = rand(100, 50)
X_norm = element_norm(X, norm())
# Result: ‖X‖₂ = 1

# L1 norm (Manhattan)
X_L1 = element_norm(X, norm(p=1))
# Result: sum(abs, X) = 1

# L∞ norm (Maximum)
X_Linf = element_norm(X, norm(p=Inf))
# Result: maximum(abs, X) = 1

# Custom p-norm
X_L4 = element_norm(X, norm(p=4))
# Result: (sum(X.^4))^(1/4) = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L153-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.scale"><a class="docstring-binding" href="#DataTreatments.scale"><code>DataTreatments.scale</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">scale(; [factor::Symbol]) -&gt; Function
scale(x::AbstractArray; kwargs...)</code></pre><p>Create a normalization function that scales data by a specified scale factor.</p><p>Scale normalization divides data by a characteristic scale measure, standardizing the spread or magnitude without necessarily centering the data. This is useful when you want to normalize variability but preserve the mean or baseline.</p><p><strong>Arguments</strong></p><ul><li><code>factor::Symbol</code>: Scale factor to use</li></ul><p><strong>Scale Factor Options</strong></p><p><strong>Standard Deviation (<code>:std</code>, default)</strong></p><p>Scale data to have standard deviation of 1.</p><p class="math-container">\[x_{\text{scaled}} = \frac{x}{\sigma}\]</p><p>where σ is the standard deviation.</p><p><strong>Median Absolute Deviation (:mad)</strong></p><p>Scale data to have median absolute deviation of 1.</p><p class="math-container">\[x_{\text{scaled}} = \frac{x}{\text{MAD}(x)}\]</p><p>where MAD = median(|x - median(x)|).</p><p><strong>First Element (:first)</strong></p><p>Scale data by the value of the first element.</p><p class="math-container">\[x_{\text{scaled}} = \frac{x}{x_1}\]</p><p><strong>Interquartile Range (:iqr)</strong></p><p>Scale data to have interquartile range of 1.</p><p class="math-container">\[x_{\text{scaled}} = \frac{x}{\text{IQR}(x)}\]</p><p>where IQR = Q₃ - Q₁ (75th percentile - 25th percentile).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Standard deviation scaling (default)
X = rand(100, 50)
X_scaled = element_norm(X, scale())
# Result: std(X_scaled) ≈ 1, mean unchanged

# Robust scaling with MAD
X_outliers = [1, 2, 3, 4, 100]  # Has outlier
X_mad = element_norm(X_outliers, scale(factor=:mad))
# More robust than std scaling

# IQR scaling
X_iqr = element_norm(X, scale(factor=:iqr))
# Result: IQR(X_iqr) ≈ 1

# Baseline normalization (first element)
prices = [100.0, 105.0, 98.0, 110.0]
prices_norm = element_norm(prices, scale(factor=:first))
# Result: [1.0, 1.05, 0.98, 1.10] - percentage of initial price</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L201-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.minmax"><a class="docstring-binding" href="#DataTreatments.minmax"><code>DataTreatments.minmax</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">minmax(; [lower::Real, upper::Real]) -&gt; Function
minmax(x::AbstractArray; kwargs...)</code></pre><p>Create a min-max normalization function that rescales data to a specified range.</p><p><strong>Arguments</strong></p><ul><li><code>lower::Real</code>: Lower bound of the output range (default: 0.0)</li><li><code>upper::Real</code>: Upper bound of the output range (default: 1.0)</li></ul><p><strong>Formula</strong></p><p class="math-container">\[x_{\text{scaled}} = \text{lower} + \frac{x - x_{\min}}{x_{\max} - x_{\min}} \cdot (\text{upper} - \text{lower})\]</p><p>This maps the original range [x<em>min, x</em>max] to [lower, upper] via affine transformation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Standard min-max scaling to [0, 1]
X = rand(100, 50)
X_norm = element_norm(X, minmax())
# Result: min ≈ 0, max ≈ 1

# Custom range scaling to [-1, 1]
X_scaled = element_norm(X, minmax(lower=-1.0, upper=1.0))
# Result: min ≈ -1, max ≈ 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L268-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.center"><a class="docstring-binding" href="#DataTreatments.center"><code>DataTreatments.center</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">center(; [method::Symbol]) -&gt; Function
center(x::AbstractArray; kwargs...)</code></pre><p>Create a centering normalization function that shifts data to have zero central tendency.</p><p>Centering (also known as mean/median centering or demeaning) translates data by  subtracting a measure of central tendency, shifting the distribution without changing  its spread or shape. This is useful for removing baseline offsets and focusing on  relative deviations.</p><p><strong>Arguments</strong></p><ul><li><code>method::Symbol</code>: Centering method (default: <code>:mean</code>)<ul><li><code>:mean</code>(default): Center around arithmetic mean (subtracts mean)</li><li><code>:median</code>: Center around median (subtracts median, more robust to outliers)</li></ul></li></ul><p><strong>Formula</strong></p><p><strong>Mean Centering (<code>:mean</code>, default)</strong></p><p class="math-container">\[x_{\text{centered}} = x - \bar{x}\]</p><p><strong>Median Centering (:median)</strong></p><p class="math-container">\[x_{\text{centered}} = x - \text{median}(x)\]</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">X = rand(100, 50)
X_centered = element_norm(X, center())
# Result: mean(X_centered) ≈ 0, std unchanged

# Median centering
X_outliers = [1, 2, 3, 4, 100]  # Has outlier
X_med = element_norm(X_outliers, center(method=:median))
# Result: median(X_med) = 0, outlier less influential</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L299-L338">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.unitpower"><a class="docstring-binding" href="#DataTreatments.unitpower"><code>DataTreatments.unitpower</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unitpower() -&gt; Function
unitpower(x::AbstractArray)</code></pre><p>Create a normalization function that scales data to have unit root mean square (RMS) power.</p><p>Unit power normalization divides each element by the root mean square (RMS) of the  entire dataset, ensuring that the normalized data has RMS = 1. This is commonly used  in signal processing to normalize signal power.</p><p><strong>Formula</strong></p><p class="math-container">\[x_{\text{normalized}} = \frac{x}{\text{RMS}(x)}\]</p><p>where the Root Mean Square (RMS) is:</p><p class="math-container">\[\text{RMS}(x) = \sqrt{\frac{1}{n}\sum_{i=1}^{n} x_i^2} = \sqrt{\text{mean}(x^2)}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Unit power normalization
X = rand(100, 50)
X_norm = element_norm(X, unitpower())
# Result: RMS(X_norm) = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L342-L368">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataTreatments.outliersuppress"><a class="docstring-binding" href="#DataTreatments.outliersuppress"><code>DataTreatments.outliersuppress</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">outliersuppress(; [thr::Real]) -&gt; Function
outliersuppress(x::AbstractArray; kwargs...)</code></pre><p>Create a normalization function that suppresses outliers by capping values beyond a threshold.</p><p>Outlier suppression identifies values that deviate more than a specified number of  standard deviations from the mean and replaces them with the threshold boundary value. This technique reduces the influence of extreme values while preserving the sign and  general structure of the data.</p><p><strong>Arguments</strong></p><ul><li><code>thr::Real=5.0</code>: Threshold in standard deviations (default: 5.0)</li></ul><p><strong>Threshold choice</strong></p><p>Lower thresholds more aggressively modify data</p><ul><li>Use thr=0.3 for typical outlier removal (3-sigma rule)</li><li>Use thr=0.5 (default) for conservative outlier handling</li></ul><p><strong>Formula</strong></p><p class="math-container">\[x_{\text{suppressed}} = \begin{cases}
\mu + \text{thr} \cdot \sigma &amp; \text{if } x &gt; \mu + \text{thr} \cdot \sigma \\
\mu - \text{thr} \cdot \sigma &amp; \text{if } x &lt; \mu - \text{thr} \cdot \sigma \\
x &amp; \text{otherwise}
\end{cases}\]</p><p>where:</p><ul><li>μ is the mean of the data</li><li>σ is the standard deviation</li><li>Values within [μ - thr·σ, μ + thr·σ] remain unchanged</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Default threshold (0.5 standard deviations)
X = [1, 2, 3, 4, 5, 100]  # 100 is an outlier
X_suppressed = element_norm(X, outliersuppress())
# Result: [1, 2, 3, 4, 5, ~mean+5*std] - outlier capped

# More aggressive suppression (3 std)
X_aggressive = element_norm(X, outliersuppress(thr=0.3))
# Caps values beyond mean ± 3*std (more values affected)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PasoStudio73/DataTreatments.jl/blob/7919732be28adaac0e7aedfdf09c767a2f86cb98/src/normalize.jl#L372-L415">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../featureset/">« FeatureSet</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 24 January 2026 21:31">Saturday 24 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
